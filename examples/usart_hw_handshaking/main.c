/* ----------------------------------------------------------------------------
 *         SAM Software Package License 
 * ----------------------------------------------------------------------------
 * Copyright (c) 2014, Atmel Corporation
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the disclaimer below.
 *
 * Atmel's name may not be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ----------------------------------------------------------------------------
 */
/**
 *  \page usart_hw_handshaking USART Hardware Handshaking Example
 *
 *  \section Purpose
 *
 *  This example demonstrates the hardware handshaking mode (i.e. RTS/CTS)
 *  provided by the USART peripherals on SAMV7 microcontrollers. The practical
 *  use of hardware handshaking is that it allows to stop transfer on the USART
 *  without losing any data in the process. This is very useful for applications
 *  that need to program slow memories for example.
 *
 *  \section Requirements
 *
 *  This example can be used on SAM V71 Xplained Ultra board directly.
 *  It requires a fly some serial lines with hardware control support( TXD and RXD cross over,
 *  RTS and CTS cross over) to connect the PINs and PC.
 *  Connection: 
 *     USART0 CTS0 (D39)
 *     USART0 RTS0 (D40)
 *     USART0 RXD0 (D14)
 *     USART0 TXD0 (D15)
 *
 *  \section Description
 *
 *  The provided program uses hardware handshaking mode to regulate the data
 *  rate of an incoming file transfer. A terminal application, such as
 *  hyper-terminal, is used to send a text file to the device (without any
 *  protocol such as X-modem). The device will enforce the configured
 *  bytes per second (bps) rate with its Request To Send (RTS) line.
 *
 *  Whenever the data rate meet or exceed the configurable threshold, the device
 *  stops receiving data on the USART. Since no buffer is provided to the XDMA,
 *  this will set the RTS line, telling the computer to stop sending data. Each
 *  second, the current data rate and total number of bytes received are
 *  displayed; the transfer is also restarted.
 *
 *  Note that the device may receive slightly less bytes than the actual file
 *  size, depending on the nature of the file. This does NOT mean that bytes
 *  have been lost: this is simply an issue with how line breaks are transmitted
 *  by the terminal. It is therefore better to use binary files, as they most
 *  often do not contain line breaks. For example, send one of the object files
 *  generated by the compiler.
 *
 *  \section Usage
 *
 *  -# Build the program and download it inside the SAM V71 Xplained Ultra board. Please
 *     refer to the Getting Started with SAM V71 Microcontrollers.pdf
 *  -# Connect a serial cable to a USART port on the evaluation kit.
 *  -# On the computer, open and configure a terminal application (e.g.
 *     HyperTerminal on Microsoft Windows) with these settings:
 *        - 115200 baud rates
 *        - 8 data bits
 *        - No parity
 *        - 1 stop bit
 *        - Hardware flow control (RTS/CTS)
 *  -# Start the application. The following traces shall appear on the debug terminal:
 *     \code
 *     -- USART Hardware Handshaking Example xxx --
 *     -- SAMxxxxx-xx
 *     -- Compiled: xxx xx xxxx xx:xx:xx --
 *     -I- Configure system tick to get 1ms tick period.
*      -I- Please send a file to serial port (USART0)
 *     Total bytes received 0x0
 *     \endcode
 *  -# Send a file in text format to the device. On HyperTerminal, this is done
 *     by selecting "Transfer -> Send Text File" (this does not prevent you from
 *     sending binary files). The transfer will start and the device will update
 *     the bytes received counter on the terminal.
 *  -# Whenever the transfer is complete, the total number of bytes received
 *     should match the size of the sent file (unless it is a text file, see
 *     explanation in description section).
 *
 *  \section References
 *  - usart_hw_handshaking/main.c
 *  - pio.h
 *  - usart_dma.h
 *  - usart.h
 */

/** \file
 *
 *  This file contains all the specific code for the usart_hw_handshaking.
 */

/*------------------------------------------------------------------------------
 *         Headers
 *------------------------------------------------------------------------------*/

#include "board.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

/*------------------------------------------------------------------------------
 *         Local definition
 *------------------------------------------------------------------------------*/

/** Size of the receive buffer used by the DMA, in bytes.*/
#define BUFFER_SIZE             64

/** Pins for USART */
#define PINS_USART              PIN_USART0_TXD, PIN_USART0_RXD, PIN_USART0_RTS, PIN_USART0_CTS

/** Register base for USART */
#define BASE_USART              USART0

/** Register base for USART */
#define BASE_USART_IRQ          USART0_IRQn

/** ID for USART */
#define ID_USART                ID_USART0

#define USART_Interrupt         USART0_Handler

   
/* USART DMA LLI size ---- should not be less than 2*/
#define USART_DMA_LLI           10

#define APP_BUFFER              ( 100*1024)                             // 100 KB
#define RX_BUFFER               ( BUFFER_SIZE * USART_DMA_LLI )         // RingBuffer's Size
#define MIN_FREE_BYTES          ( BUFFER_SIZE * (USART_DMA_LLI-1) )     // min free bytes in ring buffer

#define XDMA_NVIC_PRIO          1
#define USART_NVIC_PRIO         3
#define TC_NVIC_PRIO            4

/* Define NO_INIT attribute */
#if defined   ( __CC_ARM   )
    #define COMPILER_NAME               "KEIL"
#elif defined ( __ICCARM__ )
    #define COMPILER_NAME               "IAR"
#elif defined (  __GNUC__  )
    #define COMPILER_NAME               "GCC"
#endif

/*------------------------------------------------------------------------------
 *          Type
 * ------------------------------------------------------------------------------*/
 /* RingBuffer structure */
COMPILER_PACK_SET(4)
typedef struct
{
  uint8_t               *pBuffer;       /* RingBuffer's data buffer */
  const uint8_t         reserved[3];    /* reserved */
  uint32_t              BuffSize;       /* RinBuffer's Size */
  volatile uint32_t     Count;          /* Unread bytes in buffer */
  volatile uint32_t     *pHead;         /* Head pointer of buffer */
  uint32_t              pTail;          /* Tail pointer of buffer */
} RignBuffer_t;
COMPILER_PACK_RESET()
/*------------------------------------------------------------------------------
 *          Local variables
 * ------------------------------------------------------------------------------*/
/** Global DMA driver for all transfer */
static sXdmad dmad;

static UsartDma Usartd;
static UsartChannel UsartTx, UsartRx;


/**  Pins to configure for the application.*/
const Pin pins[] = {PINS_USART};

/**  Number of bytes received between two timer ticks.*/

volatile uint8_t semaphore = 0;
volatile uint8_t dmaflush = 0;
static uint32_t TotalbytesReceived = 0;

/**  Ring buffer */
uint8_t pRxBuffer[RX_BUFFER] ;

/**  Application Rx buffer.*/
uint8_t pMemBuff[APP_BUFFER];

COMPILER_WORD_ALIGNED RignBuffer_t *pUsartBuffer;

static void _DmaRxCallback( uint8_t status, void* pArg );

/*----------------------------------------------------------------------------
 *         Local functions
 *----------------------------------------------------------------------------*/

/**
* \brief This function updates the Count variable of ring buffer 
**/
__STATIC_INLINE void _UpdateCount(void)
{
    /* check if there is detain ring buffer  */
    if(pUsartBuffer->pTail != *pUsartBuffer->pHead )
    {
        if(pUsartBuffer->pTail > *pUsartBuffer->pHead )
        {
            pUsartBuffer->Count = (pUsartBuffer->BuffSize - (pUsartBuffer->pTail % *pUsartBuffer->pHead));
        }
        else
        {
            pUsartBuffer->Count = (*pUsartBuffer->pHead % pUsartBuffer->pTail);
        }
        memory_sync();
    }
    TRACE_DEBUG("COUNT is %d \n\r",pUsartBuffer->Count); 
}

/**
 * ISR for XDMA interrupt
 */
void XDMAC_Handler(void)
{
    XDMAD_Handler(&dmad);
}

/**
 *  \brief USART interrupt routine to serve Timeout interrupts from USART
 */
void USART_Interrupt(void)
{
    uint32_t status = BASE_USART->US_CSR;
    
    if(status & US_CSR_TIMEOUT)
    {        
        /* calculate the number of bytes in circular buffer */
        USART_AcknowledgeRxTimeOut(BASE_USART, 0);
        /* Flush the DMA FIFO */
        XDMAC_SoftwareFlushReq(dmad.pXdmacs, UsartRx.ChNum);  
        dmaflush++;
        TRACE_INFO(" Time out \n\r");
    }
}

/**
 *  \brief Callback function for DMA receiving.
 */
static void _DmaRxCallback( uint8_t status, void* pArg )
{  
      get_lock(&semaphore);
      _UpdateCount();
      free_lock(&semaphore);
      if (__LDREXW(&pUsartBuffer->Count) >= MIN_FREE_BYTES)
      {
          // Send signal to Tx side to stop sending data after filling all except one block of buffer
          BASE_USART->US_CR = US_CR_RTSEN; 
      }
      
}

/**
 * \brief Initialize circular buffer 
*/
static void _initCircularBuffer(RignBuffer_t *pBuff)
{
    pBuff->pBuffer = &pRxBuffer[0];
    pBuff->BuffSize = RX_BUFFER;    
    pBuff->pTail = (uint32_t )pRxBuffer;
    // point Head pointer of buffer to Destination address of DMA
    pBuff->pHead = &dmad.pXdmacs->XDMAC_CHID[UsartRx.ChNum].XDMAC_CDA;
    pBuff->Count = 0;
}

/**
 *  \brief USART hardware handshaking configuration
 *
 * Configures USART in hardware handshaking mode, asynchronous, 8 bits, 1 stop
 * bit, no parity, 115200 baud rates and enables its transmitter and receiver.
 */
static void _ConfigureUsart( uint32_t baudrate, uint32_t rxTimeout )
{
    uint32_t mode = 0
                    | US_MR_USART_MODE_HW_HANDSHAKING
                    | US_MR_USCLKS_MCK
                    | US_MR_CHRL_8_BIT
                    | US_MR_PAR_NO
                    | US_MR_NBSTOP_1_BIT
                    | US_MR_CHMODE_NORMAL ;

    /* Enable the peripheral clock in the PMC*/
    PMC_EnablePeripheral( ID_USART );
    
    dmad.pXdmacs = XDMAC;
    /* Reset the Tx and Rx Channel */
    memset(&UsartTx, 0, sizeof(UsartChannel));
    memset(&UsartRx, 0, sizeof(UsartChannel));
     
    /* Initialize the Rx DMA channel of USART*/
    UsartRx.BuffSize= BUFFER_SIZE;
    UsartRx.pBuff = pRxBuffer;
    UsartRx.callback = _DmaRxCallback;
    UsartRx.dmaProgrammingMode = XDMAD_LLI;
    UsartRx.dmaBlockSize = USART_DMA_LLI;
    UsartRx.dmaRingBuffer = 1;
    
    UsartRx.dmaProgress = 1;

    USARTD_Configure(&Usartd, BASE_USART, ID_USART, mode, baudrate, BOARD_MCK, &dmad);
    
    NVIC_ClearPendingIRQ(BASE_USART_IRQ);
    NVIC_SetPriority( BASE_USART_IRQ , USART_NVIC_PRIO);
    
    USART_EnableIt(BASE_USART, US_IER_TIMEOUT);
    
    NVIC_EnableIRQ(BASE_USART_IRQ);
    USART_EnableRecvTimeOut( BASE_USART, rxTimeout);
	TRACE_INFO("Baudrate is set to %u and TimeOut is %u", baudrate, rxTimeout);
}

/**
    \brief Ring buffer management 
*/
static uint32_t RingBufferRead(RignBuffer_t *pBuff, uint8_t *pDestination, uint32_t Len)
{
    uint32_t EndAddrs = ( (uint32_t)pBuff->pBuffer + pBuff->BuffSize);
    uint32_t UnreadCount = 0;
    uint32_t EnableRTS = 0;
    uint32_t TailAddrs;
    
    UnreadCount = __LDREXW(&pBuff->Count);          // unread bytes count
    if(dmaflush)
    {
        dmaflush--;
        BASE_USART->US_CR = US_CR_RTSEN;            // disable transimission
        __disable_irq();
        get_lock(&semaphore);        
        _UpdateCount();
        UnreadCount = pBuff->Count;
        memory_barrier();
        /* If Circular buffer has still free space to fill */
        if( pBuff->Count < MIN_FREE_BYTES )
        {
          EnableRTS = US_CR_RTSDIS;            
        }
        free_lock(&semaphore);
        BASE_USART->US_CR = EnableRTS;
        __enable_irq();
    }
    
    
    if(UnreadCount !=0)
    {
        Len = (Len > UnreadCount) ? UnreadCount : Len;
        
        // if read length surpasses the ring buffer boundry, then loop over
        if( (pBuff->pTail + Len) >= EndAddrs)
        {
            memcpy( pDestination , (uint32_t *)pBuff->pTail, (EndAddrs - pBuff->pTail) );
            memcpy( (pDestination +(EndAddrs - pBuff->pTail)) , (uint32_t *)pBuff->pTail, Len - (EndAddrs - pBuff->pTail) );
            TailAddrs = ( (uint32_t)pBuff->pBuffer + (Len - (EndAddrs - pBuff->pTail)));
        }
        else
        {
            memcpy( pDestination , (uint32_t *)pBuff->pTail, Len );
            TailAddrs = pBuff->pTail + Len;
        }
        /* In this part function enable the RTS signal to stop all reception
        disable irq to enter in critical part gets a lock on semaphore
        updates Tail pointer and count of ring buffer
        check if RTS need to be disable to accept the data from host
        frees the semaphore and enable irq*/
        BASE_USART->US_CR = US_CR_RTSEN;              // disable transimission
        __disable_irq();
        get_lock(&semaphore);                         // lock semaphore
        pBuff->pTail = TailAddrs;
        pBuff->Count -=Len;                           // update count of ring buffer
        /* If Circular buffer is read completely */
        if( pUsartBuffer->Count < MIN_FREE_BYTES )
        {
          EnableRTS = US_CR_RTSDIS;            
        }
        free_lock(&semaphore);
        BASE_USART->US_CR = EnableRTS;
        __enable_irq();
        
        TotalbytesReceived +=Len;
        printf("\r Total bytes received 0x%x (%u)", TotalbytesReceived, TotalbytesReceived);
        return Len;
    }
    else
    {
        return 0;
    }
}


/*------------------------------------------------------------------------------*/
/*         Global functions                                                     */
/*------------------------------------------------------------------------------*/

/**
 *  \brief usart-hw-handshaking Application entry point..
 *
 *  Configures USART in hardware handshaking mode and
 *  Timer Counter 0 to generate an interrupt every second. Then, start the first
 *  transfer on the USART and wait in an endless loop.
 *
 *  \return Unused (ANSI-C compatibility).
 */
int main( void )
{
    char pbaud_time[8];
    uint32_t BytesRead, BytesToRead, baudrate, timeout;
    static uint8_t AppBufferRollOver = 0;
    static uint8_t *pTxBuff;
    
    /* Disable watchdog*/
    WDT_Disable( WDT ) ;
 
    printf( "-- USART Hardware Handshaking Example %s --\n\r", SOFTPACK_VERSION ) ;
    printf( "-- %s\n\r", BOARD_NAME ) ;
    printf( "-- Compiled: %s %s  With %s--\n\r", __DATE__, __TIME__ , COMPILER_NAME) ;
    
    /* Enable I and D cache */
    SCB_EnableICache();
    SCB_EnableDCache();

    /* Configure USART pins*/
    PIO_Configure( pins, PIO_LISTSIZE( pins ) ) ;
    
    /* Configure systick for 1 ms. */
    TimeTick_Configure ();
    
    NVIC_SetPriority( XDMAC_IRQn , XDMA_NVIC_PRIO);
    
    
    printf("\n\rEnter required baudrate:");
    gets(pbaud_time);
    baudrate = (atoi(pbaud_time)) ? (atoi(pbaud_time)): 921600;
    printf("\n\rEnter required timeout (in microsec):");
    gets(pbaud_time);
        
    timeout = atoi(pbaud_time);
    if(timeout > 1000)
    {
        timeout /= 1000;
        timeout = ( ( timeout * baudrate) / 1000 );
    }
    else
    {
        timeout = ( timeout * baudrate) / 1000000 ;
    }
    timeout = (timeout) ? (timeout): 0x1FFFF;
    /* Configure USART */
    _ConfigureUsart(baudrate, timeout) ; 
    printf("\n\r");
    
    /*Enable Rx channel of USART */
    USARTD_EnableRxChannels(&Usartd, &UsartRx);
    
    /* Start receiving data and start timer*/
    USARTD_RcvData( &Usartd );
    
    /*Initialize Ring buffer */
    pUsartBuffer = (RignBuffer_t *)malloc(sizeof(RignBuffer_t));
    _initCircularBuffer(pUsartBuffer);
    
    pTxBuff = &pMemBuff[0];    
    
    printf( "-I- Please send a file to serial port (USART0) \n\r") ;
    BytesToRead = MIN_FREE_BYTES; // Bytes to read from ring-buffer
    while(1)
    {
      /* Check Application buffer (100 KB)overflow */
        if( (pTxBuff+BytesToRead) > &pMemBuff[APP_BUFFER - 1] )
        {
            BytesToRead = (&pMemBuff[APP_BUFFER -1] - pTxBuff);
            AppBufferRollOver = 1; // Roll over and start copying to the beginning of Application buffer to avoid errors
        }
      
        /* Read ring buffer */
        BytesRead =  RingBufferRead(pUsartBuffer, pTxBuff, BytesToRead);
        if(AppBufferRollOver)
        {
            pTxBuff = &pMemBuff[0];
            AppBufferRollOver = 0;
            BytesToRead = MIN_FREE_BYTES; // Bytes to read from ring-buffer
        }
        else
        {
            pTxBuff += BytesRead;            
        }        
    }
    
}
/** \endcond */
